"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfig = exports.Config = exports.LintConfig = void 0;
const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");
const path_1 = require("path");
const colorette_1 = require("colorette");
const builtIn_1 = require("./builtIn");
const builtinRules = require("../rules/builtin");
const utils_1 = require("../utils");
const lint_1 = require("../lint");
const recommended_1 = require("./recommended");
const redocly_1 = require("../redocly");
const IGNORE_FILE = '.redocly.lint-ignore.yaml';
const IGNORE_BANNER = `# This file instructs Redocly's linter to ignore the rules contained for specific parts of your API.\n` +
    `# See https://redoc.ly/docs/cli/ for more information.\n`;
class LintConfig {
    constructor(rawConfig, configFile) {
        this.rawConfig = rawConfig;
        this.configFile = configFile;
        this.ignore = {};
        this._usedRules = new Set();
        this._usedVersions = new Set();
        this.recommendedFallback = false;
        this.plugins = rawConfig.plugins ? resolvePlugins(rawConfig.plugins, configFile) : [];
        this.plugins.push({
            id: '',
            rules: builtinRules.rules,
            preprocessors: builtinRules.preprocessors,
            decorators: builtinRules.decorators,
        });
        if (!rawConfig.extends) {
            this.recommendedFallback = true;
        }
        const extendConfigs = rawConfig.extends
            ? resolvePresets(rawConfig.extends, this.plugins)
            : [recommended_1.default];
        if (rawConfig.rules || rawConfig.preprocessors || rawConfig.decorators) {
            extendConfigs.push({
                rules: rawConfig.rules,
                preprocessors: rawConfig.preprocessors,
                decorators: rawConfig.decorators,
            });
        }
        const merged = mergeExtends(extendConfigs);
        this.rules = {
            [lint_1.OasVersion.Version2]: Object.assign(Object.assign({}, merged.rules), merged.oas2Rules),
            [lint_1.OasVersion.Version3_0]: Object.assign(Object.assign({}, merged.rules), merged.oas3_0Rules),
        };
        this.preprocessors = {
            [lint_1.OasVersion.Version2]: Object.assign(Object.assign({}, merged.preprocessors), merged.oas2Preprocessors),
            [lint_1.OasVersion.Version3_0]: Object.assign(Object.assign({}, merged.preprocessors), merged.oas3_0Preprocessors),
        };
        this.decorators = {
            [lint_1.OasVersion.Version2]: Object.assign(Object.assign({}, merged.decorators), merged.oas2Decorators),
            [lint_1.OasVersion.Version3_0]: Object.assign(Object.assign({}, merged.decorators), merged.oas3_0Decorators),
        };
        const dir = this.configFile ? path.dirname(this.configFile) : process.cwd();
        const ignoreFile = path.join(dir, IGNORE_FILE);
        if (fs.existsSync(ignoreFile)) {
            // TODO: parse errors
            this.ignore = yaml.safeLoad(fs.readFileSync(ignoreFile, 'utf-8'));
            // resolve ignore paths
            for (const fileName of Object.keys(this.ignore)) {
                this.ignore[path.resolve(path_1.dirname(ignoreFile), fileName)] = this.ignore[fileName];
                for (const ruleId of Object.keys(this.ignore[fileName])) {
                    this.ignore[fileName][ruleId] = new Set(this.ignore[fileName][ruleId]);
                }
                delete this.ignore[fileName];
            }
        }
    }
    saveIgnore() {
        const dir = this.configFile ? path.dirname(this.configFile) : process.cwd();
        const ignoreFile = path.join(dir, IGNORE_FILE);
        const mapped = {};
        for (const absFileName of Object.keys(this.ignore)) {
            const ignoredRules = (mapped[path.relative(dir, absFileName)] = this.ignore[absFileName]);
            for (const ruleId of Object.keys(ignoredRules)) {
                ignoredRules[ruleId] = Array.from(ignoredRules[ruleId]);
            }
        }
        fs.writeFileSync(ignoreFile, IGNORE_BANNER + yaml.safeDump(mapped));
    }
    addIgnore(problem) {
        const ignore = this.ignore;
        const loc = problem.location[0];
        if (loc.pointer === undefined)
            return;
        const fileIgnore = (ignore[loc.source.absoluteRef] = ignore[loc.source.absoluteRef] || {});
        const ruleIgnore = (fileIgnore[problem.ruleId] = fileIgnore[problem.ruleId] || new Set());
        ruleIgnore.add(loc.pointer);
    }
    addProblemToIgnore(problem) {
        const loc = problem.location[0];
        if (loc.pointer === undefined)
            return problem;
        const fileIgnore = this.ignore[loc.source.absoluteRef] || {};
        const ruleIgnore = fileIgnore[problem.ruleId];
        const ignored = ruleIgnore && ruleIgnore.has(loc.pointer);
        return ignored
            ? Object.assign(Object.assign({}, problem), { ignored }) : problem;
    }
    extendTypes(types, version) {
        let extendedTypes = types;
        for (const plugin of this.plugins) {
            if (plugin.typeExtension !== undefined) {
                switch (version) {
                    case lint_1.OasVersion.Version3_0:
                        if (!plugin.typeExtension.oas3)
                            continue;
                        extendedTypes = plugin.typeExtension.oas3(extendedTypes, version);
                    case lint_1.OasVersion.Version2:
                        if (!plugin.typeExtension.oas2)
                            continue;
                        extendedTypes = plugin.typeExtension.oas2(extendedTypes, version);
                    default:
                        throw new Error('Not implemented');
                }
            }
        }
        return extendedTypes;
    }
    getRuleSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.rules[oasVersion][ruleId] || 'off';
        if (typeof settings === 'string') {
            return {
                severity: settings,
            };
        }
        else {
            return Object.assign({ severity: 'error' }, settings);
        }
    }
    getPreprocessorSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.preprocessors[oasVersion][ruleId] || 'off';
        if (typeof settings === 'string') {
            return {
                severity: settings === 'on' ? 'error' : settings,
            };
        }
        else {
            return Object.assign({ severity: 'error' }, settings);
        }
    }
    getDecoratorSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.decorators[oasVersion][ruleId] || 'off';
        if (typeof settings === 'string') {
            return {
                severity: settings === 'on' ? 'error' : settings,
            };
        }
        else {
            return Object.assign({ severity: 'error' }, settings);
        }
    }
    getUnusedRules() {
        const rules = [];
        const decorators = [];
        const preprocessors = [];
        for (const usedVersion of Array.from(this._usedVersions)) {
            rules.push(...Object.keys(this.rules[usedVersion]).filter((name) => !this._usedRules.has(name)));
            decorators.push(...Object.keys(this.decorators[usedVersion]).filter((name) => !this._usedRules.has(name)));
            preprocessors.push(...Object.keys(this.preprocessors[usedVersion]).filter((name) => !this._usedRules.has(name)));
        }
        return {
            rules,
            preprocessors,
            decorators,
        };
    }
    getRulesForOasVersion(version) {
        switch (version) {
            case lint_1.OasMajorVersion.Version3:
                const oas3Rules = []; // default ruleset
                this.plugins.forEach((p) => { var _a; return ((_a = p.preprocessors) === null || _a === void 0 ? void 0 : _a.oas3) && oas3Rules.push(p.preprocessors.oas3); });
                this.plugins.forEach((p) => { var _a; return ((_a = p.rules) === null || _a === void 0 ? void 0 : _a.oas3) && oas3Rules.push(p.rules.oas3); });
                this.plugins.forEach((p) => { var _a; return ((_a = p.decorators) === null || _a === void 0 ? void 0 : _a.oas3) && oas3Rules.push(p.decorators.oas3); });
                return oas3Rules;
            case lint_1.OasMajorVersion.Version2:
                const oas2Rules = []; // default ruleset
                this.plugins.forEach((p) => { var _a; return ((_a = p.preprocessors) === null || _a === void 0 ? void 0 : _a.oas2) && oas2Rules.push(p.preprocessors.oas2); });
                this.plugins.forEach((p) => { var _a; return ((_a = p.rules) === null || _a === void 0 ? void 0 : _a.oas2) && oas2Rules.push(p.rules.oas2); });
                this.plugins.forEach((p) => { var _a; return ((_a = p.decorators) === null || _a === void 0 ? void 0 : _a.oas2) && oas2Rules.push(p.decorators.oas2); });
                return oas2Rules;
        }
    }
    skipRules(rules) {
        for (const ruleId of rules || []) {
            for (const version of Object.values(lint_1.OasVersion)) {
                if (this.rules[version][ruleId]) {
                    this.rules[version][ruleId] = 'off';
                }
            }
        }
    }
    skipPreprocessors(preprocessors) {
        for (const preprocessorId of preprocessors || []) {
            for (const version of Object.values(lint_1.OasVersion)) {
                if (this.preprocessors[version][preprocessorId]) {
                    this.preprocessors[version][preprocessorId] = 'off';
                }
            }
        }
    }
    skipDecorators(decorators) {
        for (const decoratorId of decorators || []) {
            for (const version of Object.values(lint_1.OasVersion)) {
                if (this.decorators[version][decoratorId]) {
                    this.decorators[version][decoratorId] = 'off';
                }
            }
        }
    }
}
exports.LintConfig = LintConfig;
class Config {
    constructor(rawConfig, configFile) {
        var _a, _b, _c;
        this.rawConfig = rawConfig;
        this.configFile = configFile;
        this.apiDefinitions = rawConfig.apiDefinitions || {};
        this.lint = new LintConfig(rawConfig.lint || {}, configFile);
        this.referenceDocs = rawConfig.referenceDocs || {};
        this.resolve = {
            http: {
                headers: (_c = (_b = (_a = rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.resolve) === null || _a === void 0 ? void 0 : _a.http) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : [],
                customFetch: undefined,
            },
        };
    }
}
exports.Config = Config;
function loadConfig(configPath, customExtends) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (configPath === undefined) {
            configPath = yield findConfig();
        }
        let rawConfig = {};
        // let resolvedPlugins: Plugin[] = [];
        if (configPath !== undefined) {
            try {
                rawConfig = (yield utils_1.loadYaml(configPath));
            }
            catch (e) {
                throw new Error(`Error parsing config file at \`${configPath}\`: ${e.message}`);
            }
        }
        if (customExtends !== undefined) {
            rawConfig.lint = rawConfig.lint || {};
            rawConfig.lint.extends = customExtends;
        }
        const redoclyClient = new redocly_1.RedoclyClient();
        if (redoclyClient.hasToken()) {
            if (!rawConfig.resolve)
                rawConfig.resolve = {};
            if (!rawConfig.resolve.http)
                rawConfig.resolve.http = {};
            rawConfig.resolve.http.headers = [
                {
                    matches: `https://api.${process.env.REDOCLY_DOMAIN || 'redoc.ly'}/registry/**`,
                    name: 'Authorization',
                    envVariable: undefined,
                    value: (redoclyClient && (yield redoclyClient.getAuthorizationHeader())) || '',
                },
                ...((_a = rawConfig.resolve.http.headers) !== null && _a !== void 0 ? _a : []),
            ];
        }
        return new Config(rawConfig, configPath);
    });
}
exports.loadConfig = loadConfig;
function findConfig() {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield existsAsync('.redocly.yaml')) {
            return '.redocly.yaml';
        }
        else if (yield existsAsync('.redocly.yml')) {
            return '.redocly.yml';
        }
        return undefined;
    });
}
function existsAsync(path) {
    return new Promise(function (resolve) {
        fs.exists(path, resolve);
    });
}
function resolvePresets(presets, plugins) {
    return presets.map((presetName) => {
        var _a;
        let preset = builtIn_1.builtInConfigs[presetName];
        if (!preset && presetName.indexOf('/') > -1) {
            const [pluginName, configName] = presetName.split('/');
            const plugin = plugins.find((p) => p.id === pluginName);
            if (!plugin) {
                throw new Error(`Invalid config ${colorette_1.red(presetName)}: plugin ${pluginName} is not included.`);
            }
            preset = (_a = plugin.configs) === null || _a === void 0 ? void 0 : _a[configName];
            if (!preset) {
                throw new Error(`Invalid config ${colorette_1.red(presetName)}: plugin ${pluginName} doesn't export config with name ${configName}.`);
            }
            return preset;
        }
        if (!preset) {
            throw new Error(`Invalid config ${colorette_1.red(presetName)}: there is no such built-in config.`);
        }
        return preset;
    });
}
function resolvePlugins(plugins, configPath = '') {
    if (!plugins)
        return [];
    // @ts-ignore
    const requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
    const seenPluginIds = new Map();
    return plugins
        .map((p) => {
        // TODO: resolve npm packages similar to eslint
        const plugin = typeof p === 'string'
            ? requireFunc(path.resolve(path.dirname(configPath), p))
            : p;
        const id = plugin.id;
        if (!id) {
            throw new Error(colorette_1.red(`Plugin must define \`id\` property in ${colorette_1.blue(p.toString())}.`));
        }
        if (seenPluginIds.has(id)) {
            const pluginPath = seenPluginIds.get(id);
            throw new Error(colorette_1.red(`Plugin "id" must be unique. Plugin ${colorette_1.blue(p.toString())} uses id "${colorette_1.blue(id)}" already seen in ${colorette_1.blue(pluginPath)}`));
        }
        seenPluginIds.set(id, p.toString());
        if (plugin.rules) {
            if (!plugin.rules.oas3 && !plugin.rules.oas2) {
                throw new Error(`Plugin rules must have \`oas3\` or \`oas2\` rules "${p}.`);
            }
            if (plugin.rules.oas3) {
                plugin.rules.oas3 = prefixRules(plugin.rules.oas3, id);
            }
            if (plugin.rules.oas2) {
                plugin.rules.oas2 = prefixRules(plugin.rules.oas2, id);
            }
        }
        if (plugin.preprocessors) {
            if (!plugin.preprocessors.oas3 && !plugin.preprocessors.oas2) {
                throw new Error(`Plugin \`preprocessors\` must have \`oas3\` or \`oas2\` preprocessors "${p}.`);
            }
            if (plugin.preprocessors.oas3) {
                plugin.preprocessors.oas3 = prefixRules(plugin.preprocessors.oas3, id);
            }
            if (plugin.preprocessors.oas2) {
                plugin.preprocessors.oas2 = prefixRules(plugin.preprocessors.oas2, id);
            }
        }
        if (plugin.decorators) {
            if (!plugin.decorators.oas3 && !plugin.decorators.oas2) {
                throw new Error(`Plugin \`decorators\` must have \`oas3\` or \`oas2\` decorators "${p}.`);
            }
            if (plugin.decorators.oas3) {
                plugin.decorators.oas3 = prefixRules(plugin.decorators.oas3, id);
            }
            if (plugin.decorators.oas2) {
                plugin.decorators.oas2 = prefixRules(plugin.decorators.oas2, id);
            }
        }
        return plugin;
    })
        .filter(utils_1.notUndefined);
}
function prefixRules(rules, prefix) {
    const res = {};
    for (const name of Object.keys(rules)) {
        res[`${prefix}/${name}`] = rules[name];
    }
    return res;
}
function mergeExtends(rulesConfList) {
    const result = {
        rules: {},
        oas2Rules: {},
        oas3_0Rules: {},
        preprocessors: {},
        oas2Preprocessors: {},
        oas3_0Preprocessors: {},
        decorators: {},
        oas2Decorators: {},
        oas3_0Decorators: {},
    };
    for (let rulesConf of rulesConfList) {
        if (rulesConf.extends) {
            throw new Error(`\`extends\` is not supported in shared configs yet: ${JSON.stringify(rulesConf, null, 2)}.`);
        }
        Object.assign(result.rules, rulesConf.rules);
        Object.assign(result.oas2Rules, rulesConf.oas2Rules);
        assignExisting(result.oas2Rules, rulesConf.rules || {});
        Object.assign(result.oas3_0Rules, rulesConf.oas3_0Rules);
        assignExisting(result.oas3_0Rules, rulesConf.rules || {});
        Object.assign(result.preprocessors, rulesConf.preprocessors);
        Object.assign(result.oas2Preprocessors, rulesConf.oas2Preprocessors);
        assignExisting(result.oas2Preprocessors, rulesConf.preprocessors || {});
        Object.assign(result.oas3_0Preprocessors, rulesConf.oas3_0Preprocessors);
        assignExisting(result.oas3_0Preprocessors, rulesConf.preprocessors || {});
        Object.assign(result.decorators, rulesConf.decorators);
        Object.assign(result.oas2Decorators, rulesConf.oas2Decorators);
        assignExisting(result.oas2Decorators, rulesConf.decorators || {});
        Object.assign(result.oas3_0Decorators, rulesConf.oas3_0Decorators);
        assignExisting(result.oas3_0Decorators, rulesConf.decorators || {});
    }
    return result;
}
function assignExisting(target, obj) {
    for (let k of Object.keys(obj)) {
        if (target.hasOwnProperty(k)) {
            target[k] = obj[k];
        }
    }
}
